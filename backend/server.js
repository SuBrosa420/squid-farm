const express = require('express');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞
app.use(cors({
  origin: [
    'https://web.telegram.org',
    'https://t.me',
    'http://localhost:5173' // –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  ],
  credentials: true
}));
app.use(express.json());

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
const dbPath = path.join(__dirname, 'squid_farm.db');
const db = new sqlite3.Database(dbPath);

// –°–û–ó–î–ê–ï–ú –¢–ê–ë–õ–ò–¶–´ –° –ü–†–ê–í–ò–õ–¨–ù–û–ô –°–¢–†–£–ö–¢–£–†–û–ô
db.serialize(() => {
  console.log('üóÉÔ∏è Creating database tables...');
  
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    telegram_id INTEGER UNIQUE NOT NULL,
    eggs DECIMAL(15,2) DEFAULT 0,
    squid_count INTEGER DEFAULT 0,
    ton_balance DECIMAL(15,6) DEFAULT 0,
    claimed_free_eggs BOOLEAN DEFAULT FALSE,
    last_production_update DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`, (err) => {
    if (err) {
      console.error('‚ùå Error creating users table:', err);
    } else {
      console.log('‚úÖ Users table created successfully');
    }
  });
});

// –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function getSimpleUser(telegramId, callback) {
  db.get(
    'SELECT * FROM users WHERE telegram_id = ?', 
    [telegramId],
    (err, user) => {
      if (err) {
        console.error('Database error:', err);
        callback(null, err);
      } else {
        callback(user, null);
      }
    }
  );
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function createUser(telegramId, callback) {
  console.log(`üë§ Creating new user: ${telegramId}`);
  db.run(
    'INSERT INTO users (telegram_id) VALUES (?)',
    [telegramId],
    function(err) {
      if (err) {
        console.error('Error creating user:', err);
        callback(null, err);
      } else {
        console.log(`‚úÖ User created with ID: ${this.lastID}`);
        getSimpleUser(telegramId, callback);
      }
    }
  );
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ —è–∏—Ü
function updateEggProduction(userId, callback) {
  console.log(`üîÑ Updating production for user ${userId}`);
  
  db.get(
    `SELECT eggs, squid_count, last_production_update, created_at 
     FROM users WHERE id = ?`,
    [userId],
    (err, user) => {
      if (err || !user) {
        console.error('‚ùå Error fetching user for production:', err);
        return callback(0);
      }

      console.log(`üìä User data: eggs=${user.eggs}, squids=${user.squid_count}, last_update=${user.last_production_update}`);
      
      const now = new Date();
      const lastUpdate = new Date(user.last_production_update || user.created_at || now);
      const secondsPassed = Math.max(0, (now - lastUpdate) / 1000);
      
      console.log(`‚è∞ Time passed: ${secondsPassed.toFixed(1)} seconds`);
      
      let newEggs = parseFloat(user.eggs);
      let production = 0;
      
      if (secondsPassed > 0 && user.squid_count > 0) {
        // 40 —è–∏—Ü/—á–∞—Å = 40/3600 = 0.011111 —è–∏—Ü/—Å–µ–∫—É–Ω–¥—É –∑–∞ –∫–∞–ª—å–º–∞—Ä–∞
        production = user.squid_count * 0.011111 * secondsPassed;
        newEggs += production;
        
        console.log(`ü•ö Production: ${production.toFixed(4)} eggs (${user.squid_count} squids √ó ${secondsPassed.toFixed(1)}s)`);
        console.log(`üí∞ New total: ${user.eggs} -> ${newEggs.toFixed(4)} eggs`);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤ –±–∞–∑–µ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ
        db.run(
          'UPDATE users SET eggs = ?, last_production_update = ? WHERE id = ?',
          [newEggs, now.toISOString(), userId],
          (updateErr) => {
            if (updateErr) {
              console.error('‚ùå Error updating eggs:', updateErr);
              callback(parseFloat(user.eggs));
            } else {
              console.log(`‚úÖ Successfully updated eggs in database`);
              callback(newEggs);
            }
          }
        );
      } else {
        console.log('‚ÑπÔ∏è No production: no squids or no time passed');
        callback(newEggs);
      }
    }
  );
}

// –ú–∞—Ä—à—Ä—É—Ç—ã API

// Health check
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    message: 'Squid Farm API is running'
  });
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.post('/api/user', (req, res) => {
  const { telegramId } = req.body;
  
  if (!telegramId) {
    return res.status(400).json({ error: 'Telegram ID is required' });
  }

  console.log(`\nüì• GET /api/user for telegramId: ${telegramId}`);

  getSimpleUser(telegramId, (user, err) => {
    if (err) {
      console.error('‚ùå Database error:', err);
      return res.status(500).json({ error: 'Database error' });
    }
    
    if (!user) {
      console.log('üë§ User not found, creating new one');
      createUser(telegramId, (newUser, createErr) => {
        if (createErr) {
          return res.status(500).json({ error: 'Error creating user' });
        }
        console.log(`‚úÖ New user created, sending data`);
        res.json({
          success: true,
          eggs: parseFloat(newUser.eggs),
          squidCount: newUser.squid_count,
          tonBalance: parseFloat(newUser.ton_balance),
          claimedFreeEggs: Boolean(newUser.claimed_free_eggs)
        });
      });
    } else {
      console.log(`üë§ Found existing user: ID=${user.id}, eggs=${user.eggs}, squids=${user.squid_count}`);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ
      updateEggProduction(user.id, (updatedEggs) => {
        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        getSimpleUser(telegramId, (updatedUser, fetchErr) => {
          if (fetchErr || !updatedUser) {
            return res.status(500).json({ error: 'Error fetching updated user' });
          }
          
          console.log(`üì§ Sending updated data: eggs=${updatedUser.eggs}, squids=${updatedUser.squid_count}`);
          
          res.json({
            success: true,
            eggs: parseFloat(updatedUser.eggs),
            squidCount: updatedUser.squid_count,
            tonBalance: parseFloat(updatedUser.ton_balance),
            claimedFreeEggs: Boolean(updatedUser.claimed_free_eggs)
          });
        });
      });
    }
  });
});

// Claim –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö —è–∏—Ü
app.post('/api/claim', (req, res) => {
  const { telegramId } = req.body;
  
  if (!telegramId) {
    return res.status(400).json({ error: 'Telegram ID is required' });
  }

  console.log(`\nüéÅ CLAIM for telegramId: ${telegramId}`);

  getSimpleUser(telegramId, (user, err) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    if (user.claimed_free_eggs) {
      return res.status(400).json({ error: 'You have already claimed your free eggs' });
    }

    // –í—ã–¥–∞–µ–º 3000 —è–∏—Ü
    const newEggs = parseFloat(user.eggs) + 3000;
    const now = new Date().toISOString();
    
    console.log(`üí∞ Giving 3000 eggs: ${user.eggs} -> ${newEggs}`);
    
    db.run(
      'UPDATE users SET eggs = ?, claimed_free_eggs = 1, last_production_update = ? WHERE id = ?',
      [newEggs, now, user.id],
      function(err) {
        if (err) {
          console.error('‚ùå Error claiming eggs:', err);
          return res.status(500).json({ error: 'Error claiming eggs' });
        }
        
        console.log(`‚úÖ Successfully claimed 3000 eggs`);
        
        res.json({ 
          success: true, 
          eggs: newEggs,
          message: 'Successfully claimed 3000 eggs!'
        });
      }
    );
  });
});

// –í—ã–ª—É–ø–ª–µ–Ω–∏–µ –∫–∞–ª—å–º–∞—Ä–æ–≤ - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
app.post('/api/hatch', (req, res) => {
  const { telegramId, amount } = req.body;
  
  if (!telegramId) {
    return res.status(400).json({ error: 'Telegram ID is required' });
  }
  
  if (!amount || amount < 1) {
    return res.status(400).json({ error: 'Invalid amount' });
  }

  console.log(`\nüê£ HATCH ${amount} squids for telegramId: ${telegramId}`);

  getSimpleUser(telegramId, (user, err) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // –°–Ω–∞—á–∞–ª–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ
    updateEggProduction(user.id, (currentEggs) => {
      const eggCost = amount * 100;

      console.log(`üí≥ Hatching check: ${currentEggs.toFixed(2)} eggs available, need ${eggCost} eggs`);

      if (currentEggs < eggCost) {
        console.log(`‚ùå Not enough eggs for hatching`);
        return res.status(400).json({ 
          error: `Not enough eggs. You need ${eggCost} eggs, but have only ${Math.floor(currentEggs)}` 
        });
      }

      // –í—ã–ª—É–ø–ª—è–µ–º –∫–∞–ª—å–º–∞—Ä–æ–≤
      const newEggs = currentEggs - eggCost;
      const newSquidCount = user.squid_count + amount;
      const now = new Date().toISOString();
      
      console.log(`‚úÖ Hatching: eggs ${currentEggs.toFixed(2)} -> ${newEggs.toFixed(2)}, squids ${user.squid_count} -> ${newSquidCount}`);
      
      // –û–ë–ù–û–í–õ–Ø–ï–ú –° last_production_update —á—Ç–æ–±—ã —Å–±—Ä–æ—Å–∏—Ç—å —Ç–∞–π–º–µ—Ä
      db.run(
        'UPDATE users SET eggs = ?, squid_count = ?, last_production_update = ? WHERE id = ?',
        [newEggs, newSquidCount, now, user.id],
        function(err) {
          if (err) {
            console.error('‚ùå Error hatching squids:', err);
            return res.status(500).json({ error: 'Error hatching squids' });
          }
          
          console.log(`üéâ Successfully hatched ${amount} squids`);
          
          res.json({ 
            success: true, 
            newEggs: newEggs,
            newSquidCount: newSquidCount,
            message: `Successfully hatched ${amount} squid(s)!`
          });
        }
      );
    });
  });
});

// –ü—Ä–æ–¥–∞–∂–∞ —è–∏—Ü
app.post('/api/sell', (req, res) => {
  const { telegramId, amount } = req.body;
  
  if (!telegramId) {
    return res.status(400).json({ error: 'Telegram ID is required' });
  }
  
  if (!amount || amount < 1) {
    return res.status(400).json({ error: 'Invalid amount' });
  }

  console.log(`\nüí∞ SELL ${amount} batches for telegramId: ${telegramId}`);

  getSimpleUser(telegramId, (user, err) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // –°–Ω–∞—á–∞–ª–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ
    updateEggProduction(user.id, (currentEggs) => {
      const eggAmount = amount * 100;
      const tonReward = amount * 0.01;
      const now = new Date().toISOString();

      console.log(`üí≥ Selling check: ${currentEggs.toFixed(2)} eggs available, need ${eggAmount} eggs`);

      if (currentEggs < eggAmount) {
        console.log(`‚ùå Not enough eggs for selling`);
        return res.status(400).json({ 
          error: `Not enough eggs. You need ${eggAmount} eggs, but have only ${Math.floor(currentEggs)}` 
        });
      }

      // –ü—Ä–æ–¥–∞–µ–º —è–π—Ü–∞
      const newEggs = currentEggs - eggAmount;
      const newTonBalance = parseFloat(user.ton_balance) + tonReward;
      
      console.log(`‚úÖ Selling: eggs ${currentEggs.toFixed(2)} -> ${newEggs.toFixed(2)}, TON ${user.ton_balance} -> ${newTonBalance.toFixed(6)}`);
      
      // –û–ë–ù–û–í–õ–Ø–ï–ú –° last_production_update
      db.run(
        'UPDATE users SET eggs = ?, ton_balance = ?, last_production_update = ? WHERE id = ?',
        [newEggs, newTonBalance, now, user.id],
        function(err) {
          if (err) {
            console.error('‚ùå Error selling eggs:', err);
            return res.status(500).json({ error: 'Error selling eggs' });
          }
          
          console.log(`üéâ Successfully sold ${eggAmount} eggs for ${tonReward} TON`);
          
          res.json({ 
            success: true, 
            newEggs: newEggs,
            newTonBalance: newTonBalance,
            message: `Successfully sold ${eggAmount} eggs for ${tonReward.toFixed(6)} TON!`
          });
        }
      );
    });
  });
});

// –ö–æ—Ä–Ω–µ–≤–æ–π –º–∞—Ä—à—Ä—É—Ç
app.get('/', (req, res) => {
  res.json({ 
    message: 'Squid Farm API Server', 
    version: '1.0.0',
    status: 'running'
  });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, () => {
  console.log(`\nüéâ Squid Farm backend server running on http://localhost:${PORT}`);
  console.log(`üîß Debug mode: Detailed logging enabled`);
  console.log(`üóÉÔ∏è Database: ${dbPath}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nüõë Shutting down server...');
  db.close();
  process.exit(0);
});